# План миграции CoffeeScript -> TypeScript (боевой, для декомпозиции задач)

<!-- AICODE-NOTE: NAV/TS-MIGRATION-PLAN - подробный план миграции CoffeeScript→TS с критериями готовности; ref: README.md; risk: миграция “вслепую” ломает сборку/артефакты/контракты -->

Цель: внедрить TypeScript так, чтобы:
1) не потерять функциональность и совместимость выходных артефактов;
2) получить реальную пользу от типизации (не “перевод ради перевода”);
3) уменьшить риск регрессий через тесты и поэтапные критерии готовности.

Этот документ написан так, чтобы его можно было отдавать джуниорам для выполнения задач небольшими итерациями.

---

## Контекст репозитория (важно для плана)

В проекте несколько модулей/пакетов, связанных сборкой на Grunt:
- `omega-build/` — оркестратор сборки (grunt-hub).
- `omega-pac/` — генерация PAC и алгоритмы правил/профилей; тесты есть.
- `omega-target/` — ядро логики опций/профилей/sync/storage; тесты есть.
- `omega-web/` — Angular UI на CoffeeScript + grunt/bower.
- `omega-target-chromium-extension/` — WebExtension цель + сборка/manifest + интеграция модулей.

Текущие сборки ядра (`omega-pac`, `omega-target`) завязаны на `browserify` + `coffeeify` и генерируют `index.js` из `index.coffee`, плюс браузерные бандлы `omega_*.min.js`.

---

## Принцип 20/80 (как тестируем и что типизируем первым)

20/80 здесь означает:
- мы не пытаемся покрыть тестами/типами “всё”;
- приоритет — **контракты данных** и **границы модулей**, которые дают максимальный эффект при изменениях.

Критические области (приоритет 1):
- генерация PAC (`omega-pac`): профили/правила/conditions/shexp → строка PAC/AST;
- правила/матчинг профилей (`omega-pac`): правильный выбор профиля;
- merge/sync опций (`omega-target`): сохранение инвариантов при слиянии;
- storage (`omega-target`): корректная сериализация/ошибки/недоступность;
- импорт/экспорт (если логика в ядре): совместимость формата.

Критические области (приоритет 2):
- интеграции (extension ↔ target/web): корректные публичные API и формат сообщений;
- UI (как потребитель API): можно держать legacy дольше, если ядро стабильно.

---

## Стратегия миграции (принято)

Фиксируем стратегию для всего проекта:

**CoffeeScript → JavaScript → TypeScript**, с приоритетом на ядро (`omega-pac`, `omega-target`).

Почему так:
- это самый управляемый путь для команды с джунами: изменения поведения отделяются от внедрения типов;
- проще сохранять текущий формат модулей (CommonJS) и существующий пайплайн сборки;
- легче ловить регрессии тестами: сначала “эквивалентный JS”, затем постепенное усиление типизации.

---

## Уровень типизации (принято)

Цель первого этапа — максимум эффекта за минимум усилий. Фиксируем это как правило проекта:

### Базовый уровень (обязательный): T1 для ядра
Требования для `omega-pac` и `omega-target`:
- **публичные API модулей** имеют явные типы;
- основные **доменные структуры** (профили/правила/условия/options/sync/storage) имеют типы;
- I/O границы (“входы/выходы”) типизированы: что принимаем, что возвращаем.

### Усиленный уровень (точечно, только где окупается): T2 для критичных узлов
Требования:
- внутри критичной логики минимизируем `any`;
- на внешних границах используем `unknown` и делаем явное приведение/валидацию;
- “мешки” данных (например, неструктурированные options) постепенно заменяем на явные типы.

Точки применения T2 (фиксируем как обязательные цели миграции):
- `omega-pac`: генерация PAC + матчинг профилей/правил;
- `omega-target`: merge/sync + storage.

### UI и extension в первой волне
- `omega-web` остаётся legacy: типизируем только границы/контракты через `omega-target` (без полной TS-миграции UI).
- `omega-target-chromium-extension`: типизируем границы интеграции и сообщения, без переписывания всего на TS до стабилизации ядра.

---

## Тестовая стратегия (что добавить до и во время миграции)

Правило: любой PR по миграции должен либо:
- менять только “механику” (rename/перенос/компиляция) без изменения поведения, и это доказывается тестами/снапшотами; либо
- явно менять поведение и сопровождаться тестом на новый контракт (с объяснением).

### База (что уже есть)
- `omega-pac/test/*.coffee` — покрывает conditions/pac_generator/profiles/rule_list и т.п.
- `omega-target/test/options_sync.coffee` — покрывает часть sync/merge поведения.

### Что обязательно добавить (пояс безопасности 20/80)
Ниже — список тестов, которые дают максимум защиты в миграции.

#### omega-pac (приоритет 1)
1) **Golden/snapshot тесты на генерацию PAC**:
   - фиксированный набор профилей/правил → результат PAC (строка);
   - отдельно кейсы SOCKS/SOCKS5/HTTP/HTTPS, fallback, DIRECT;
   - кейсы с условиями/shexp (краевые значения, регистры, домены).
2) **Контракт на выбор профиля**:
   - набор правил → ожидаемый matchResult (профиль + источник).
3) **Набор “регрессионных” входов**:
   - один файл/набор JSON-фикстуров, который можно расширять по мере багов.

#### omega-target (приоритет 1)
1) **Контрактные тесты merge/sync**:
   - “disabled sync” семантика (не перезатирать локально отключённое);
   - конфликтные значения, отсутствие ключей, удаление/добавление профилей;
   - сценарии с “квотой”/ошибками, где появляются `syncError`.
2) **Storage: сериализация/ошибки**:
   - гарантировать одинаковое поведение при недоступном storage;
   - проверка, что ключевые сущности round-trip’ятся без потерь.

#### Интеграции (приоритет 2)
1) **smoke сборки**:
   - сборка `omega-pac`/`omega-target` должна давать те же entrypoints (`index.js`) и не ломать require’ы;
   - сборка extension (минимальный “build smoke”) — хотя бы в CI/локально перед релизом.

---

## Этап 0. Подготовка (обязательный, до TypeScript)

Цель этапа: сделать миграцию измеримой и несломать артефакты/контракты.

0.1) Зафиксировать ограничения (как “контракты миграции”)
- Что считается “совместимостью”:
  - `omega-pac/index.js` и `omega-target/index.js` должны продолжать экспортировать тот же публичный API (CommonJS).
  - Браузерные бандлы (`omega_pac.min.js`, `omega_target.min.js`) остаются работоспособны.
- Что нельзя менять без отдельного RFC/решения:
  - формат/семантика PAC-выхода (кроме явно согласованных фиксов);
  - формат экспортируемых настроек/профилей, если есть внешние потребители.

0.2) “Карта миграции” по файлам/компонентам (для декомпозиции)
- Для каждого модуля составить таблицу:
  - файл/папка;
  - роль (entrypoint, доменная модель, утилита, интеграция);
  - риск (высокий/средний/низкий);
  - стратегия (переводим рано/позже/оставляем legacy).

0.3) Усилить тесты (минимальный “пояс безопасности”)
- Добавить 5–10 тестов из раздела “Тестовая стратегия” в `omega-pac` и `omega-target`.
- Критерий готовности: тесты стабильны и проходят локально.

**Критерии готовности этапа 0**
- Тесты зелёные:
  - `cd omega-pac && npm test`
  - `cd omega-target && npm test`
- Есть список “контрактов миграции” (выше) и карта миграции (0.2).

---

## Этап 1. Техническая база TypeScript (без миграции логики)

Цель: подготовить инфраструктуру так, чтобы можно было добавлять TS по одному файлу, не ломая текущий пайплайн.

Важно: здесь не должно быть “больших переписок логики”. Только plumbing.

### 1.1) Как TS попадает в текущую сборку (принято)
Для `omega-pac` и `omega-target` используем схему:

**TypeScript компилируется `tsc` в JS**, после чего текущий `browserify` собирает артефакты из JS.

Причина:
- минимально трогаем существующие Grunt/browserify пайплайны;
- проще дебажить: ошибки компиляции TS отделены от bundling.

### 1.2) Задать “скелет” конфигурации TS
- В каждом модуле ядра завести отдельный `tsconfig.json` (или общий базовый + наследование).
- Пока без жёсткого `strict` (он включается позже по компонентам), но с минимумом здравого смысла:
  - `module`: `commonjs`
  - `target`: согласовать с текущими ожиданиями сборки/окружений
  - `declaration`: `false` (в первой волне не публикуем typings как артефакт, а фиксируем типы внутри репо)
  - `noEmitOnError`: `true` для “падающих” сборок

#### 1.2.1) Чек-лист совместимости TS→JS с текущей сборкой (browserify/minifyify)
Цель: в рамках миграции **не менять** поведение и артефакты сборки, поэтому TS должен эмитить JS, который без сюрпризов проходит через текущий `browserify` пайплайн и минификацию release-бандлов.

Риски, которые ловим заранее:
- В release используется `minifyify`; старые минификаторы могут не переварить современный синтаксис (ES2015+). Значит `target`/emit нужно выбирать консервативно.
- Текущая сборка основана на CommonJS (`require/module.exports`) и ожидает стабильные entrypoints (`index.js`) и браузерные standalone-бандлы.
- В репо используются `"browser"` shim’ы в `package.json` (подмены зависимостей в браузере) — это должно остаться рабочим.

Минимальные правила (первый проход, до отдельного решения по модернизации сборщика/минификатора):
- `compilerOptions.module = "commonjs"` (сохраняем модель модулей для `browserify`).
- `compilerOptions.target = "es5"` (или максимально консервативный, который гарантированно проходит текущую минификацию).
- Временный запрет на `import()`/top-level `await`/ESM-only выход (до отдельной итерации по сборке).
- Если включаем `sourceMap`, убедиться, что это не ломает текущие задачи сборки/релиза (особенно release-бандлы).

Проверки (обязательные для PR, который трогает TS/emit/entrypoints):
- `index.js` по-прежнему экспортирует тот же публичный API (CommonJS), что и до миграции.
- Browserify-бандлы `omega_*.min.js` собираются в dev и в release режимах (минимум smoke).
- Тесты зелёные: `cd omega-pac && npm test`, `cd omega-target && npm test`.

### 1.3) Режим “совместного проживания” (coexistence)
Пока в репо есть CoffeeScript, типизация будет “расти” вокруг него:
- Для совместимости API начинаем с `*.d.ts` или `*.ts` только на “типовых фасадах” (публичные экспорты).
- Для CoffeeScript/JS модулей допускаются временные `declare module`/типовые заглушки, но с планом их сжечь.

**Критерии готовности этапа 1**
- Можно добавить 1 новый TS-файл в `omega-pac` и получить рабочий `index.js` без изменения поведения.
- Тесты по-прежнему зелёные (те же команды).

---

## Этап 2. Миграция `omega-pac` (первая цель: T1)

Почему первым: меньше внешних зависимостей, много “чистой” логики и высокий профит от типов.

### 2.1) Декомпозиция по слоям
Рекомендуемый порядок внутри `omega-pac/src`:
1) **доменные модели**: профили, правила, условия (типы данных);
2) **утилиты**: shexp/utils и т.п.;
3) **генератор PAC** (как самый критичный контракт);
4) **entrypoint** (`index.*`) и публичные экспорты.

### 2.2) Как мигрировать файлы (маленькими партиями)
Партия = 1–5 файлов или один законченный кусок.
Для каждой партии:
- выбрать цель (например, “типизируем Profile и RuleList”);
- сделать миграцию без изменения поведения;
- запустить тесты;
- при необходимости добавить 1–2 теста на новый/уточнённый контракт.

### 2.3) Какие типы делать первыми (T1-минимум)
Сначала определить типы данных, которые являются “позвоночником”:
- `Profile` (варианты: direct/pac/proxy/auto и т.д. — оформить как union);
- `Rule` / `RuleList` / `MatchResult`;
- “условия” (`Condition`) + их параметры;
- входные/выходные структуры генератора PAC.

На уровне `omega-pac` цель — чтобы основные функции имели сигнатуры вроде:
- “профили/правила” → “PAC/результат/матчинг” без `any`.

**Критерии готовности этапа 2**
- `omega-pac` достигает уровня T1: доменные типы + типизированные публичные экспорты.
- Golden/контрактные тесты на PAC проходят.
- `cd omega-pac && npm test` зелёный.

---

## Этап 3. Миграция `omega-target` (первая цель: T1, затем точечно T2)

Почему вторым: зависит от `omega-pac`, и это ядро состояния/синхронизации.

### 3.1) Где типизация окупается больше всего
Приоритетно типизировать:
- модель options/profiles (то, что сохраняется и мигрирует);
- sync/merge входы/выходы и инварианты;
- storage абстракцию и ошибки.

### 3.2) “Границы” (где допустимы слабые типы)
- внешние интеграции (browser APIs, JSON из storage, сообщения) — начинать с `unknown`, затем валидировать/приводить;
- внутри core-логики не допускать “растекания” `any`.

### 3.3) Тесты в omega-target
Перед активной миграцией расширить `omega-target/test` так, чтобы:
- merge/sync покрывали конфликтные сценарии и важные инварианты;
- storage поведение было стабильно тестируемо.

**Критерии готовности этапа 3**
- `omega-target` достигает уровня T1 по публичным API и доменным моделям.
- Ключевые merge/sync инварианты закреплены тестами.
- `cd omega-target && npm test` зелёный.

---

## Этап 4. Extension и UI (отдельное решение, не “по инерции”)

### 4.1) `omega-target-chromium-extension`
Риски:
- сборка и манифест, зависимость от `omega-target/omega-web/omega-pac`;
- регрессии часто не в логике, а в сборке/путях/экспортируемых символах.

Подход (принято):
- держать максимальную совместимость публичных API `omega-target`/`omega-web`;
- добавлять типизацию на границах сообщений/интеграций;
- вводить TS в extension только после стабилизации ядра.

Минимум “готовности”:
- smoke сборки release и dev;
- проверка, что background/options UI стартуют (ручной чек-лист).

### 4.2) `omega-web`
Это потенциально самый дорогой кусок из-за:
- Angular + CoffeeScript + bower/grunt;
- низкой отдачи типизации, если ядро уже типизировано, а UI только “провода”.

Решение на первую волну (принято):
- `omega-web` остаётся на CoffeeScript.
- Любая типизация делается через типизированные API/контракты ядра (`omega-target`, частично extension-бридж), без попыток “перевести UI на TS” параллельно с миграцией ядра.

---

## Рабочие правила для PR и задач (то, что важно донести джуниорам)

## Definition of Done (DoD): тесты + типы как “гарантии устойчивости”

Этот раздел — обязательный “контракт качества” для миграции. Он нужен, чтобы проект не скатился в TS “на бумаге”.

### DoD для любого PR по миграции (обязателен всегда)
1) **Поведение**:
   - PR не меняет поведение (по умолчанию). Если меняет — это явно описано в PR и закреплено тестом.
2) **Тесты**:
   - всегда зелёные:
     - `cd omega-pac && npm test`
     - `cd omega-target && npm test`
3) **Артефакты/экспорты**:
   - если затронуты entrypoints/сборка (`index.*`, grunt/browserify) — приложить в PR подтверждение, что:
     - `omega-pac/index.js` и `omega-target/index.js` продолжают экспортировать тот же публичный API (CommonJS),
     - браузерные бандлы не “отвалились” при сборке (минимум: сборка проходит, smoke не падает).
4) **Декомпозиция**:
   - PR маленький: 1 логическая партия (1–5 файлов или один законченный слой), без “заодно поправил”.

### DoD для уровня T1 (обязателен для ядра)
Для `omega-pac` и `omega-target` T1 считается достигнутым, когда выполнено всё:
1) **Доменные типы**:
   - есть явные типы для ключевых сущностей (см. разделы этапов 2/3), и они используются в сигнатурах функций/классов;
   - доменная модель не размазана “объектами без формы”.
2) **Публичный API типизирован**:
   - все экспортируемые наружу функции/классы/структуры имеют явные типы входов/выходов;
   - нет ситуации “наружу уходит any”.
3) **Границы I/O**:
   - входы из JSON/storage/сообщений не приводятся к `any`; используется `unknown` (или типы-обёртки) и явное приведение/валидация.

### DoD для уровня T2 (обязателен только для критичных узлов)
T2 применяется только в зафиксированных “точках боли”, но там требования жёстче.

Для `omega-pac` (генерация PAC + матчинг) и `omega-target` (merge/sync + storage) T2 считается достигнутым, когда:
1) **Запрет расползания `any`**:
   - в критичных файлах/папках не допускается `any` в доменной логике (если нужно временно — только локально и с объяснением в PR).
2) **Узкие типы вместо “мешков”**:
   - профили/правила/conditions/options оформлены как union/структуры с проверяемыми полями;
   - все “режимы” (например, типы профилей) выражены типами, а не строковыми условностями “как получится”.
3) **Тесты фиксируют инварианты**:
   - каждый критичный инвариант имеет тест (1 тест — 1 инвариант), чтобы рефактор не ломал поведение “тихо”.

### Golden/contract тесты как обязательная deliverable-сущность
Чтобы миграция не меняла выходные результаты незаметно, заводим golden/fixture наборы:
- `omega-pac/test/fixtures/` — фиксированные профили/правила/входы;
- `omega-pac/test/golden_pac.coffee|.js|.ts` — тест “вход → PAC строка” (сравнение с эталоном).

Правило: изменение эталона допускается только если:
- это намеренное изменение поведения, согласованное отдельно;
- в PR есть объяснение “почему” и добавлен/обновлён контрактный тест.

### PR-правила
- Маленькие PR: 1 тема/партия, понятный diff.
- В PR-описании всегда:
  - что именно мигрировали;
  - есть ли изменение поведения (должно быть “нет”, если не согласовано);
  - какие тесты запускались (`omega-pac`, `omega-target`).
- Если есть сомнение по поведению — добавь тест/фикстуру, не “проверяй глазами”.

### Гейты (обязательные проверки, чтобы не деградировать качество)
Гейт = “если не выполнено, PR не мержим”.

Минимальный набор гейтов (всегда):
- `cd omega-pac && npm test`
- `cd omega-target && npm test`

Дополнительный гейт при изменениях сборки/entrypoints:
- `cd omega-build && npm run build`

Дополнительный гейт при изменениях, затрагивающих extension интеграцию (экспорты/модули/шины):
- сборка extension release должна завершаться без ошибок (как минимум локально перед merge).

### Типизация: “как не превратить TS в any”
- Нельзя “прокидывать any через всё”. Если на границе `unknown`/непонятно — типизируй границу, валидируй, дальше работай с типами.
- В ядре предпочитать:
  - discriminated unions для профилей/правил;
  - `unknown` вместо `any` на внешнем входе;
  - явные типы ошибок (например, `StorageUnavailableError`).

### Миграция файла: чеклист
Для каждого файла/партии:
1) Нет изменения поведения (или оно описано и протестировано).
2) Компиляция/сборка не меняет формат артефактов без причины.
3) Тесты зелёные.
4) Если затронут контракт — добавлен тест на инвариант.

---

## Контрольные проверки (после каждого значимого шага)

Обязательные (ядро):
- `cd omega-pac && npm test`
- `cd omega-target && npm test`

Рекомендуемые (когда затронута сборка/интеграции):
- `cd omega-build && npm run build` (может быть дольше; использовать на крупных изменениях)
- Сборка extension release (если меняли API/entrypoints ядра)
