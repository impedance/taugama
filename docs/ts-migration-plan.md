# План миграции CoffeeScript -> TypeScript (боевой, для декомпозиции задач)

<!-- AICODE-NOTE: NAV/TS-MIGRATION-PLAN - подробный план миграции CoffeeScript→TS с критериями готовности; ref: README.md; risk: миграция “вслепую” ломает сборку/артефакты/контракты -->

Цель: внедрить TypeScript так, чтобы:
1) не потерять функциональность и совместимость выходных артефактов;
2) получить реальную пользу от типизации (не “перевод ради перевода”);
3) уменьшить риск регрессий через тесты и поэтапные критерии готовности.

Этот документ написан так, чтобы его можно было отдавать джуниорам для выполнения задач небольшими итерациями.

---

## Контекст репозитория (важно для плана)

В проекте несколько модулей/пакетов, связанных сборкой на Grunt:
- `omega-build/` — оркестратор сборки (grunt-hub).
- `omega-pac/` — генерация PAC и алгоритмы правил/профилей; тесты есть.
- `omega-target/` — ядро логики опций/профилей/sync/storage; тесты есть.
- `omega-web/` — Angular UI на CoffeeScript + grunt/bower.
- `omega-target-chromium-extension/` — WebExtension цель + сборка/manifest + интеграция модулей.

Текущие сборки ядра (`omega-pac`, `omega-target`) завязаны на `browserify` + `coffeeify` и генерируют `index.js` из `index.coffee`, плюс браузерные бандлы `omega_*.min.js`.

---

## Принцип 20/80 (как тестируем и что типизируем первым)

20/80 здесь означает:
- мы не пытаемся покрыть тестами/типами “всё”;
- приоритет — **контракты данных** и **границы модулей**, которые дают максимальный эффект при изменениях.

Критические области (приоритет 1):
- генерация PAC (`omega-pac`): профили/правила/conditions/shexp → строка PAC/AST;
- правила/матчинг профилей (`omega-pac`): правильный выбор профиля;
- merge/sync опций (`omega-target`): сохранение инвариантов при слиянии;
- storage (`omega-target`): корректная сериализация/ошибки/недоступность;
- импорт/экспорт (если логика в ядре): совместимость формата.

Критические области (приоритет 2):
- интеграции (extension ↔ target/web): корректные публичные API и формат сообщений;
- UI (как потребитель API): можно держать legacy дольше, если ядро стабильно.

---

## Стратегия миграции (принято)

Фиксируем стратегию для всего проекта:

**CoffeeScript → JavaScript → TypeScript**, с приоритетом на ядро (`omega-pac`, `omega-target`).

Почему так:
- это самый управляемый путь для команды с джунами: изменения поведения отделяются от внедрения типов;
- проще сохранять текущий формат модулей (CommonJS) и существующий пайплайн сборки;
- легче ловить регрессии тестами: сначала “эквивалентный JS”, затем постепенное усиление типизации.

---

## Уровень типизации (принято)

Цель первого этапа — максимум эффекта за минимум усилий. Фиксируем это как правило проекта:

### Базовый уровень (обязательный): T1 для ядра
Требования для `omega-pac` и `omega-target`:
- **публичные API модулей** имеют явные типы;
- основные **доменные структуры** (профили/правила/условия/options/sync/storage) имеют типы;
- I/O границы (“входы/выходы”) типизированы: что принимаем, что возвращаем.

### Усиленный уровень (точечно, только где окупается): T2 для критичных узлов
Требования:
- внутри критичной логики минимизируем `any`;
- на внешних границах используем `unknown` и делаем явное приведение/валидацию;
- “мешки” данных (например, неструктурированные options) постепенно заменяем на явные типы.

Точки применения T2 (фиксируем как обязательные цели миграции):
- `omega-pac`: генерация PAC + матчинг профилей/правил;
- `omega-target`: merge/sync + storage.

### UI и extension в первой волне
- `omega-web` остаётся legacy: типизируем только границы/контракты через `omega-target` (без полной TS-миграции UI).
- `omega-target-chromium-extension`: типизируем границы интеграции и сообщения, без переписывания всего на TS до стабилизации ядра.

---

## Тестовая стратегия (что добавить до и во время миграции)

Правило: любой PR по миграции должен либо:
- менять только “механику” (rename/перенос/компиляция) без изменения поведения, и это доказывается тестами/снапшотами; либо
- явно менять поведение и сопровождаться тестом на новый контракт (с объяснением).

### База (что уже есть)
- `omega-pac/test/*.coffee` — покрывает conditions/pac_generator/profiles/rule_list и т.п.
- `omega-target/test/options_sync.coffee` — покрывает часть sync/merge поведения.

### Что обязательно добавить (пояс безопасности 20/80)
Ниже — список тестов, которые дают максимум защиты в миграции.

#### omega-pac (приоритет 1)
1) **Golden/snapshot тесты на генерацию PAC**:
   - фиксированный набор профилей/правил → результат PAC (строка);
   - отдельно кейсы SOCKS/SOCKS5/HTTP/HTTPS, fallback, DIRECT;
   - кейсы с условиями/shexp (краевые значения, регистры, домены).
2) **Контракт на выбор профиля**:
   - набор правил → ожидаемый matchResult (профиль + источник).
3) **Набор “регрессионных” входов**:
   - один файл/набор JSON-фикстуров, который можно расширять по мере багов.

#### omega-target (приоритет 1)
1) **Контрактные тесты merge/sync**:
   - “disabled sync” семантика (не перезатирать локально отключённое);
   - конфликтные значения, отсутствие ключей, удаление/добавление профилей;
   - сценарии с “квотой”/ошибками, где появляются `syncError`.
2) **Storage: сериализация/ошибки**:
   - гарантировать одинаковое поведение при недоступном storage;
   - проверка, что ключевые сущности round-trip’ятся без потерь.

#### Интеграции (приоритет 2)
1) **smoke сборки**:
   - сборка `omega-pac`/`omega-target` должна давать те же entrypoints (`index.js`) и не ломать require’ы;
   - сборка extension (минимальный “build smoke”) — хотя бы в CI/локально перед релизом.

---

## Этап 0. Подготовка (обязательный, до TypeScript)

Цель этапа: сделать миграцию измеримой и несломать артефакты/контракты.

### 0.0) Стабилизация окружения и воспроизводимость (обязательный pre-flight)

Это задачи, которые стоит выполнить **до** начала этапа 1 (внедрения TS plumbing), чтобы:
- снизить риск “у меня собирается, у тебя/в CI — нет”;
- зафиксировать базовую точку для будущих PR миграции;
- не смешивать проблемы TS с проблемами окружения/зависимостей.

0.0.1) Выровнять версии Node между локальной разработкой, README и CI
- Сейчас:
  - `.nvmrc` фиксирует Node 20;
  - GitHub Actions релиз собирает на Node 22 (`.github/workflows/release.yml`);
  - в репо есть устаревший CircleCI на Node 7 (`.circleci/config.yml`).
- Решение (принять и зафиксировать одним PR):
  - выбрать “каноническую” версию Node (рекомендация: **Node 20**, как в `.nvmrc` и `README.md`);
  - привести CI к этой версии;
  - CircleCI либо удалить, либо явно отключить/обновить (чтобы не был источником ложной уверенности).

0.0.2) Зафиксировать зависимости (lock-файлы) и перейти на воспроизводимую установку
- Сейчас lock-файлов нет → `npm install` может дать разные деревья в разные дни.
- Минимум:
  - добавить `package-lock.json` в каждый модуль (`omega-build`, `omega-pac`, `omega-target`, `omega-web`, `omega-target-chromium-extension`);
  - в CI использовать `npm ci` там, где возможно (и обновить инструкции/скрипты соответственно).

0.0.3) Добавить “build smoke” для сборки расширения (минимальная проверка артефактов)
- Поскольку миграция затрагивает сборку/entrypoints, важно уметь быстро проверить, что хотя бы “собирается”.
- Минимум (локально и/или в CI):
  - `cd omega-build && npm run deps && npm run dev && npm run build`
  - `cd omega-build && npm run release` (или эквивалентная команда) и проверка, что `dist/*.zip` создаются.

0.0.4) Подсветить и устранить предупреждения, которые будут “мешать шумом” при миграции
- Пример: предупреждение Node про некорректный `main` у `omega-pac` при тестах `omega-target`.
- Цель: чтобы предупреждения не маскировали реальные проблемы TS/сборки.

0.0.5) Зафиксировать “измеримую” совместимость артефактов (минимум для ядра)
- В миграции важно избежать ситуации “по идее эквивалентно, но глазами не проверили”.
- Минимальный набор проверок (добавить до активной миграции или в первых PR этапа 2/3):
  - Golden-тесты `omega-pac`: 3–5 фикстур “профили/правила → PAC строка” со сравнением с эталоном.
  - Контрактные тесты `omega-target`: 3–5 сценариев merge/sync/storage, каждый тест = 1 инвариант.
- Критерий готовности: эти тесты стабильны и не зависят от таймингов/окружения (исключить flaky).

0.1) Зафиксировать ограничения (как “контракты миграции”)
- Что считается “совместимостью”:
  - `omega-pac/index.js` и `omega-target/index.js` должны продолжать экспортировать тот же публичный API (CommonJS).
  - Браузерные бандлы (`omega_pac.min.js`, `omega_target.min.js`) остаются работоспособны.
- Что нельзя менять без отдельного RFC/решения:
  - формат/семантика PAC-выхода (кроме явно согласованных фиксов);
  - формат экспортируемых настроек/профилей, если есть внешние потребители.

0.2) “Карта миграции” по файлам/компонентам (для декомпозиции)
- Для каждого модуля составить таблицу:
  - файл/папка;
  - роль (entrypoint, доменная модель, утилита, интеграция);
  - риск (высокий/средний/низкий);
  - стратегия (переводим рано/позже/оставляем legacy).

### 0.2.1) Шаблон “карты миграции” (готовый для задач джунам)

Формат: 1 строка = 1 “кусок ответственности”, который можно превратить в PR.

| Path | Роль | Риск | Стратегия | Что сделать в этой итерации | Как найти/проверить |
|---|---|---:|---|---|---|
| `<path>` | entrypoint/domain/util/integration/test/build | высокий/средний/низкий | рано/позже/legacy | 1–2 предложения | `rg -n ...` + какие тесты |

Правила:
- Не пытаться заполнить “всё в репо” сразу: достаточно 10–25 строк на модуль ядра.
- Если строка получается слишком большой — разбей по подфайлам/подпапкам (лучше больше строк, но меньше риска).
- “Как найти/проверить” обязателен: джун должен уметь перейти в код и понять, что менять.

### 0.2.2) Пример “карты миграции” (минимум для старта)

Это пример, который можно сразу дробить на задачи (PR по 1 строке, максимум 2–3 близкие строки).

| Path | Роль | Риск | Стратегия | Что сделать в этой итерации | Как найти/проверить |
|---|---|---:|---|---|---|
| `omega-pac/index.coffee` | entrypoint | высокий | позже | подготовить план сохранения public API при переводе на TS (`index.ts`/`index.js`) без изменений экспортов | `rg -n "module\\.exports" omega-pac/index.coffee`; тест: `cd omega-pac && npm test` |
| `omega-pac/src/profiles.coffee` | domain | высокий | рано | выделить типы `Profile`/`Profiles` и минимально типизировать операции над ними (T1) | `rg -n "class Profiles" omega-pac/src`; тест: `cd omega-pac && npm test` |
| `omega-pac/src/pac_generator.coffee` | core | высокий | рано | типизировать вход/выход генератора PAC (T1), добавить/усилить golden-тест “вход→PAC” | `rg -n "NAV/PAC-GENERATOR|pac_generator" omega-pac/src`; тест: `cd omega-pac && npm test` |
| `omega-pac/src/shexp.coffee` | util | средний | рано | типизировать публичные функции/сигнатуры shexp; не пускать `any` наружу | `rg -n "shexp" omega-pac/src`; тест: `cd omega-pac && npm test` |
| `omega-pac/test/` | test | высокий | рано | добавить 2–3 контрактных теста на критичные инварианты (см. “Golden/contract тесты”) | `ls omega-pac/test`; запуск: `cd omega-pac && npm test` |
| `omega-target/index.coffee` | entrypoint | высокий | позже | подготовить план сохранения public API при переводе на TS (`index.ts`/`index.js`) без изменений экспортов | `rg -n "module\\.exports" omega-target/index.coffee`; тест: `cd omega-target && npm test` |
| `omega-target/src/options.coffee` | core | высокий | рано | выделить типы доменной модели options/profiles (T1) и протащить их в ключевые сигнатуры | `rg -n "NAV/OPTIONS-CORE" omega-target/src/options.coffee`; тест: `cd omega-target && npm test` |
| `omega-target/src/options_sync.coffee` | core | высокий | рано | типизировать вход/выход merge/sync, зафиксировать инварианты тестами (T1→точечно T2) | `rg -n "OptionsSync|NAV/OPTIONS-CORE" omega-target/src`; тест: `cd omega-target && npm test` |
| `omega-target/src/storage.coffee` | core | высокий | рано | типизировать storage интерфейс + ошибки (не превращать JSON в `any`) | `rg -n "NAV/STORAGE-CORE" omega-target/src/storage.coffee`; тест: `cd omega-target && npm test` |
| `omega-target/test/` | test | высокий | рано | добавить тесты на конфликтные сценарии merge/sync и деградацию storage | `ls omega-target/test`; запуск: `cd omega-target && npm test` |

0.3) Усилить тесты (минимальный “пояс безопасности”)
- Добавить 5–10 тестов из раздела “Тестовая стратегия” в `omega-pac` и `omega-target`.
- Критерий готовности: тесты стабильны и проходят локально.

**Критерии готовности этапа 0**
- Выполнен pre-flight (0.0): среда/CI согласованы, зависимости зафиксированы, есть минимальный build smoke.
- Тесты зелёные:
  - `cd omega-pac && npm test`
  - `cd omega-target && npm test`
- Есть список “контрактов миграции” (выше) и карта миграции (0.2).

---

## Этап 1. Техническая база TypeScript (без миграции логики)

Цель: подготовить инфраструктуру так, чтобы можно было добавлять TS по одному файлу, не ломая текущий пайплайн.

Важно: здесь не должно быть “больших переписок логики”. Только plumbing.

### 1.1) Как TS попадает в текущую сборку (принято)
Для `omega-pac` и `omega-target` используем схему:

**TypeScript компилируется `tsc` в JS**, после чего текущий `browserify` собирает артефакты из JS.

Причина:
- минимально трогаем существующие Grunt/browserify пайплайны;
- проще дебажить: ошибки компиляции TS отделены от bundling.

### 1.2) Задать “скелет” конфигурации TS
- В каждом модуле ядра завести отдельный `tsconfig.json` (или общий базовый + наследование).
- Пока без жёсткого `strict` (он включается позже по компонентам), но с минимумом здравого смысла:
  - `module`: `commonjs`
  - `target`: согласовать с текущими ожиданиями сборки/окружений
  - `declaration`: `false` (в первой волне не публикуем typings как артефакт, а фиксируем типы внутри репо)
  - `noEmitOnError`: `true` для “падающих” сборок

#### 1.2.1) Решение, которое нужно зафиксировать до массовой миграции (чтобы джуны не гадали)

Перед тем как раздавать задачи “переведи файл X”, нужно принять 3 решения и записать их в PR (иначе каждый PR будет спорить о структуре):

1) **Куда `tsc` пишет JS (`outDir`)**
   - Рекомендация: `outDir = "lib"` внутри `omega-pac`/`omega-target`.
   - Причина: отделяем исходники (`src/**/*.ts|coffee|js`) от сгенерированного JS, проще браузерной сборке и gitignore.

2) **Что является входом для browserify после появления TS**
   - Вариант A (предпочтительный для контроля): browserify читает **только** из `lib/**` (то есть из JS, который эмитнул `tsc`).
   - Вариант B (временный): browserify остаётся на текущих entrypoints, но PR обязан доказать, что итоговые бандлы эквивалентны (тяжелее объяснить джунам).

3) **Как делимся типами между пакетами (`omega-target` ↔ `omega-pac`)**
   - Вариант A (самый простой для джунов): временно включить `declaration: true` только в `omega-pac`, чтобы `omega-target` мог импортировать типы без хака.
   - Вариант B: не генерировать `.d.ts`, а держать общий пакет типов внутри репо (например, `omega-types/`) — сложнее организационно.
   - Вариант C: `paths` на исходники `omega-pac/src` — быстро, но легко “подставиться” при рефакторинге.

Пока решения не приняты, джунам нельзя выдавать задачи, где затрагивается межпакетный контракт типов.

##### Рекомендуемое дефолт-решение (если нет возражений и smoke проходит)
Чтобы снять неопределённость и ускорить старт, стоит зафиксировать один набор решений и менять его только отдельным PR по сборке:
- `omega-pac`: `tsc` эмитит в `omega-pac/lib/**`, `browserify` читает из `lib/**`, `declaration: true` (нужно для импорта типов в `omega-target`).
- `omega-target`: `tsc` эмитит в `omega-target/lib/**`, `browserify` читает из `lib/**`, `declaration: false` (пока не нужно для потребителей).
- Общий принцип: `rootDir = "src"` (чтобы структура путей в `lib/**` повторяла `src/**`) и не ломала относительные `require(...)`.

#### 1.2.2) Чек-лист совместимости TS→JS с текущей сборкой (browserify/minifyify)
Цель: в рамках миграции **не менять** поведение и артефакты сборки, поэтому TS должен эмитить JS, который без сюрпризов проходит через текущий `browserify` пайплайн и минификацию release-бандлов.

Риски, которые ловим заранее:
- В release используется `minifyify`; старые минификаторы могут не переварить современный синтаксис (ES2015+). Значит `target`/emit нужно выбирать консервативно.
- Текущая сборка основана на CommonJS (`require/module.exports`) и ожидает стабильные entrypoints (`index.js`) и браузерные standalone-бандлы.
- В репо используются `"browser"` shim’ы в `package.json` (подмены зависимостей в браузере) — это должно остаться рабочим.

Минимальные правила (первый проход, до отдельного решения по модернизации сборщика/минификатора):
- `compilerOptions.module = "commonjs"` (сохраняем модель модулей для `browserify`).
- `compilerOptions.target = "es5"` (или максимально консервативный, который гарантированно проходит текущую минификацию).
- Временный запрет на `import()`/top-level `await`/ESM-only выход (до отдельной итерации по сборке).
- Если включаем `sourceMap`, убедиться, что это не ломает текущие задачи сборки/релиза (особенно release-бандлы).

Проверки (обязательные для PR, который трогает TS/emit/entrypoints):
- `index.js` по-прежнему экспортирует тот же публичный API (CommonJS), что и до миграции.
- Browserify-бандлы `omega_*.min.js` собираются в dev и в release режимах (минимум smoke).
- Тесты зелёные: `cd omega-pac && npm test`, `cd omega-target && npm test`.

#### 1.2.3) Политика импортов/interop (чтобы не утонуть в мелких несовместимостях)
Миграция CoffeeScript→TS часто спотыкается об импорты CommonJS, поэтому правила лучше зафиксировать заранее:
- По умолчанию сохраняем CommonJS (`require`/`module.exports`) в runtime-коде, а `import` используем только там, где компиляция не меняет семантику `require()`.
- TS-флаги interop должны быть одинаковыми в `omega-pac` и `omega-target` и не меняться “по вкусу” в разных PR:
  - выбрать единый режим `esModuleInterop` и `allowSyntheticDefaultImports` (включить или выключить сразу в обоих пакетах);
  - любое изменение этих флагов считать “изменением сборки” и прогонять `cd omega-build && npm run build`.
- Если где-то нужен временный костыль, лучше оформить его как локальный адаптер (wrapper), чем менять глобальную политику импортов.

#### 1.2.4) Проверка минификатора/target (чтобы TS-emit не “сломал релиз”)
План исходит из консервативного `target=es5`, но это нужно подтвердить, чтобы не получить сюрприз в release:
- Выяснить, какой минификатор реально используется на release и какой синтаксис он поддерживает (ES5/ES2015+).
- Если ES2015+ поддерживается стабильно — можно поднять `target` (и упростить TS-код), но это отдельное решение/PR по сборке.
- Если ES2015+ не поддерживается — `target=es5` остаётся обязательным до миграции минификатора на `terser` (отдельный PR).

### 1.3) Режим “совместного проживания” (coexistence)
Пока в репо есть CoffeeScript, типизация будет “расти” вокруг него:
- Для совместимости API начинаем с `*.d.ts` или `*.ts` только на “типовых фасадах” (публичные экспорты).
- Для CoffeeScript/JS модулей допускаются временные `declare module`/типовые заглушки, но с планом их сжечь.

### 1.4) Runbook для джуна: добавить первый TS-файл (без миграции логики)

Цель: самый первый PR должен доказать “TS реально работает в этом модуле” и не трогать поведение.

Чеклист PR (пример для `omega-pac`, аналогично для `omega-target`):
1) Добавить `tsconfig.json` (или подключить общий базовый) и минимальный npm-скрипт:
   - `npm run typecheck` → `tsc -p . --noEmit`
   - `npm run build:ts` → `tsc -p .` (если нужен emit)
2) Добавить 1 файл `src/ts_sanity.ts` с простым экспортом/импортом (без участия в runtime).
3) Убедиться, что текущие тесты зелёные:
   - `cd omega-pac && npm test`
4) В PR-описании зафиксировать:
   - где находится `tsconfig.json`,
   - какая команда делает typecheck,
   - куда эмитится JS (если эмитится) и как он попадает в сборку.

Критично: первый PR не должен менять entrypoints, exports и сборку release-бандлов (иначе тяжело локализовать регрессии).

### 1.5) Runbook для джуна: миграция 1 файла CoffeeScript → TypeScript (без изменения поведения)

Цель: перевести один файл так, чтобы тесты и артефакты остались эквивалентны.

Шаги:
1) Выбрать файл “низкого радиуса” (risk=средний/низкий из карты миграции), без сложных интеграций.
2) Сделать промежуточный перевод CoffeeScript → JS (если это упрощает) и только потом JS → TS:
   - важно сохранить `module.exports`/`require` модель там, где это используется сейчас;
   - не менять формат данных/публичные структуры.
3) После компиляции TS убедиться, что экспорты файла совпадают (по именам и поведению).
4) Добавить минимальные типы (T1): вход/выход функций и “основные сущности” файла.
5) Прогнать тесты модуля и убедиться, что PR маленький.

Частые ловушки CoffeeScript→TS (проверить руками):
- неявный `return` → в TS нужно явно вернуть значение там, где это часть контракта;
- `@x`/`this` и биндинг функций (`=>` vs `->`) → в TS легко “потерять this”;
- `a ? b` / `?.` → семантика различается, не “улучшать” без теста;
- `in`/ranges/компрехеншены → переписать эквивалентно, без микрооптимизаций.

**Критерии готовности этапа 1**
- Можно добавить 1 новый TS-файл в `omega-pac` и получить рабочий `index.js` без изменения поведения.
- Тесты по-прежнему зелёные (те же команды).

---

## Этап 2. Миграция `omega-pac` (первая цель: T1)

Почему первым: меньше внешних зависимостей, много “чистой” логики и высокий профит от типов.

### 2.1) Декомпозиция по слоям
Рекомендуемый порядок внутри `omega-pac/src`:
1) **доменные модели**: профили, правила, условия (типы данных);
2) **утилиты**: shexp/utils и т.п.;
3) **генератор PAC** (как самый критичный контракт);
4) **entrypoint** (`index.*`) и публичные экспорты.

### 2.2) Как мигрировать файлы (маленькими партиями)
Партия = 1–5 файлов или один законченный кусок.
Для каждой партии:
- выбрать цель (например, “типизируем Profile и RuleList”);
- сделать миграцию без изменения поведения;
- запустить тесты;
- при необходимости добавить 1–2 теста на новый/уточнённый контракт.

### 2.3) Какие типы делать первыми (T1-минимум)
Сначала определить типы данных, которые являются “позвоночником”:
- `Profile` (варианты: direct/pac/proxy/auto и т.д. — оформить как union);
- `Rule` / `RuleList` / `MatchResult`;
- “условия” (`Condition`) + их параметры;
- входные/выходные структуры генератора PAC.

На уровне `omega-pac` цель — чтобы основные функции имели сигнатуры вроде:
- “профили/правила” → “PAC/результат/матчинг” без `any`.

**Критерии готовности этапа 2**
- `omega-pac` достигает уровня T1: доменные типы + типизированные публичные экспорты.
- Golden/контрактные тесты на PAC проходят.
- `cd omega-pac && npm test` зелёный.

### 2.4) Набор первых задач для джунов (omega-pac)

Каждый пункт = отдельный PR (или максимум 2 близких файла), строго по DoD.

1) “Скелет типов профиля”: добавить тип `Profile` (union по типам профилей) и протащить в 1–2 ключевых места.
   - Scope: `omega-pac/src/profiles.*`
   - Проверка: `cd omega-pac && npm test`
2) “Скелет типов правил”: `Rule`/`RuleList`/`MatchResult` без `any` наружу.
   - Scope: `omega-pac/src` (точечно по файлам из карты)
   - Проверка: `cd omega-pac && npm test`
3) “Границы генератора PAC”: типизировать вход/выход генератора + добавить/усилить golden-тест.
   - Scope: `omega-pac/src/pac_generator.*`, `omega-pac/test`
   - Проверка: `cd omega-pac && npm test`
4) “Сhexp типы”: типизировать публичные функции shexp, убрать “мешки” объектов в сигнатурах.
   - Scope: `omega-pac/src/shexp.*`
   - Проверка: `cd omega-pac && npm test`

---

## Этап 3. Миграция `omega-target` (первая цель: T1, затем точечно T2)

Почему вторым: зависит от `omega-pac`, и это ядро состояния/синхронизации.

### 3.1) Где типизация окупается больше всего
Приоритетно типизировать:
- модель options/profiles (то, что сохраняется и мигрирует);
- sync/merge входы/выходы и инварианты;
- storage абстракцию и ошибки.

### 3.2) “Границы” (где допустимы слабые типы)
- внешние интеграции (browser APIs, JSON из storage, сообщения) — начинать с `unknown`, затем валидировать/приводить;
- внутри core-логики не допускать “растекания” `any`.

### 3.3) Тесты в omega-target
Перед активной миграцией расширить `omega-target/test` так, чтобы:
- merge/sync покрывали конфликтные сценарии и важные инварианты;
- storage поведение было стабильно тестируемо.

**Критерии готовности этапа 3**
- `omega-target` достигает уровня T1 по публичным API и доменным моделям.
- Ключевые merge/sync инварианты закреплены тестами.
- `cd omega-target && npm test` зелёный.

### 3.4) Набор первых задач для джунов (omega-target)

Каждый пункт = отдельный PR (или максимум 2 близких файла), строго по DoD.

1) “Типы доменной модели options”: выделить минимальные типы options/profiles и протащить в 1–2 ключевых места.
   - Scope: `omega-target/src/options.*`
   - Проверка: `cd omega-target && npm test`
2) “Sync/merge границы”: типизировать вход/выход merge/sync, начиная с `unknown` на I/O.
   - Scope: `omega-target/src/options_sync.*`
   - Проверка: `cd omega-target && npm test`
3) “Storage интерфейс + ошибки”: типизировать storage контракт и ошибки; запретить `any` на входе из JSON.
   - Scope: `omega-target/src/storage.*`
   - Проверка: `cd omega-target && npm test`
4) “Тесты инвариантов”: добавить 2–3 теста “1 тест = 1 инвариант” вокруг merge/sync и storage.
   - Scope: `omega-target/test`
   - Проверка: `cd omega-target && npm test`

---

## Этап 4. Extension и UI (отдельное решение, не “по инерции”)

### 4.1) `omega-target-chromium-extension`
Риски:
- сборка и манифест, зависимость от `omega-target/omega-web/omega-pac`;
- регрессии часто не в логике, а в сборке/путях/экспортируемых символах.

Подход (принято):
- держать максимальную совместимость публичных API `omega-target`/`omega-web`;
- добавлять типизацию на границах сообщений/интеграций;
- вводить TS в extension только после стабилизации ядра.

Минимум “готовности”:
- smoke сборки release и dev;
- проверка, что background/options UI стартуют (ручной чек-лист).

### 4.2) `omega-web`
Это потенциально самый дорогой кусок из-за:
- Angular + CoffeeScript + bower/grunt;
- низкой отдачи типизации, если ядро уже типизировано, а UI только “провода”.

Решение на первую волну (принято):
- `omega-web` остаётся на CoffeeScript.
- Любая типизация делается через типизированные API/контракты ядра (`omega-target`, частично extension-бридж), без попыток “перевести UI на TS” параллельно с миграцией ядра.

---

## Рабочие правила для PR и задач (то, что важно донести джуниорам)

## Definition of Done (DoD): тесты + типы как “гарантии устойчивости”

Этот раздел — обязательный “контракт качества” для миграции. Он нужен, чтобы проект не скатился в TS “на бумаге”.

### DoD для любого PR по миграции (обязателен всегда)
1) **Поведение**:
   - PR не меняет поведение (по умолчанию). Если меняет — это явно описано в PR и закреплено тестом.
2) **Тесты**:
   - всегда зелёные:
     - `cd omega-pac && npm test`
     - `cd omega-target && npm test`
3) **Артефакты/экспорты**:
   - если затронуты entrypoints/сборка (`index.*`, grunt/browserify) — приложить в PR подтверждение, что:
     - `omega-pac/index.js` и `omega-target/index.js` продолжают экспортировать тот же публичный API (CommonJS),
     - браузерные бандлы не “отвалились” при сборке (минимум: сборка проходит, smoke не падает).
4) **Декомпозиция**:
   - PR маленький: 1 логическая партия (1–5 файлов или один законченный слой), без “заодно поправил”.

### DoD для уровня T1 (обязателен для ядра)
Для `omega-pac` и `omega-target` T1 считается достигнутым, когда выполнено всё:
1) **Доменные типы**:
   - есть явные типы для ключевых сущностей (см. разделы этапов 2/3), и они используются в сигнатурах функций/классов;
   - доменная модель не размазана “объектами без формы”.
2) **Публичный API типизирован**:
   - все экспортируемые наружу функции/классы/структуры имеют явные типы входов/выходов;
   - нет ситуации “наружу уходит any”.
3) **Границы I/O**:
   - входы из JSON/storage/сообщений не приводятся к `any`; используется `unknown` (или типы-обёртки) и явное приведение/валидация.

### DoD для уровня T2 (обязателен только для критичных узлов)
T2 применяется только в зафиксированных “точках боли”, но там требования жёстче.

Для `omega-pac` (генерация PAC + матчинг) и `omega-target` (merge/sync + storage) T2 считается достигнутым, когда:
1) **Запрет расползания `any`**:
   - в критичных файлах/папках не допускается `any` в доменной логике (если нужно временно — только локально и с объяснением в PR).
2) **Узкие типы вместо “мешков”**:
   - профили/правила/conditions/options оформлены как union/структуры с проверяемыми полями;
   - все “режимы” (например, типы профилей) выражены типами, а не строковыми условностями “как получится”.
3) **Тесты фиксируют инварианты**:
   - каждый критичный инвариант имеет тест (1 тест — 1 инвариант), чтобы рефактор не ломал поведение “тихо”.

### Golden/contract тесты как обязательная deliverable-сущность
Чтобы миграция не меняла выходные результаты незаметно, заводим golden/fixture наборы:
- `omega-pac/test/fixtures/` — фиксированные профили/правила/входы;
- `omega-pac/test/golden_pac.coffee|.js|.ts` — тест “вход → PAC строка” (сравнение с эталоном).

Правило: изменение эталона допускается только если:
- это намеренное изменение поведения, согласованное отдельно;
- в PR есть объяснение “почему” и добавлен/обновлён контрактный тест.

### PR-правила
- Маленькие PR: 1 тема/партия, понятный diff.
- В PR-описании всегда:
  - что именно мигрировали;
  - есть ли изменение поведения (должно быть “нет”, если не согласовано);
  - какие тесты запускались (`omega-pac`, `omega-target`).
- Если есть сомнение по поведению — добавь тест/фикстуру, не “проверяй глазами”.

### Гейты (обязательные проверки, чтобы не деградировать качество)
Гейт = “если не выполнено, PR не мержим”.

Минимальный набор гейтов (всегда):
- `cd omega-pac && npm test`
- `cd omega-target && npm test`

Дополнительный гейт при изменениях сборки/entrypoints:
- `cd omega-build && npm run build`

Дополнительный гейт при изменениях, затрагивающих extension интеграцию (экспорты/модули/шины):
- сборка extension release должна завершаться без ошибок (как минимум локально перед merge).

Рекомендация: когда считать, что “затронута сборка” (чтобы не спорить в PR)
- Меняли `tsconfig.json`/TS-emit/interop-флаги или пути (`outDir`, `rootDir`).
- Меняли grunt/browserify/minifyify задачи или их входы/entrypoints.
- Меняли `index.*` и публичные экспорты модулей.

### Типизация: “как не превратить TS в any”
- Нельзя “прокидывать any через всё”. Если на границе `unknown`/непонятно — типизируй границу, валидируй, дальше работай с типами.
- В ядре предпочитать:
  - discriminated unions для профилей/правил;
  - `unknown` вместо `any` на внешнем входе;
  - явные типы ошибок (например, `StorageUnavailableError`).

### Миграция файла: чеклист
Для каждого файла/партии:
1) Нет изменения поведения (или оно описано и протестировано).
2) Компиляция/сборка не меняет формат артефактов без причины.
3) Тесты зелёные.
4) Если затронут контракт — добавлен тест на инвариант.

---

## Контрольные проверки (после каждого значимого шага)

Обязательные (ядро):
- `cd omega-pac && npm test`
- `cd omega-target && npm test`

Рекомендуемые (когда затронута сборка/интеграции):
- `cd omega-build && npm run build` (может быть дольше; использовать на крупных изменениях)
- Сборка extension release (если меняли API/entrypoints ядра)
